#![cfg(feature = "crypto")]

use crate::{CryptoProvider, Error, Result};

pub struct DefaultCryptoProvider;

impl DefaultCryptoProvider {
    pub fn new() -> Self {
        DefaultCryptoProvider {}
    }
}

impl CryptoProvider for DefaultCryptoProvider {
    fn sha256(&self, message: &[u8]) -> Vec<u8> {
        use sha2::{Digest, Sha256};

        let mut hasher = Sha256::new();
        hasher.update(message);

        hasher.finalize().to_vec()
    }

    fn blake2b(&self, message: &[u8], size: usize) -> Result<Vec<u8>> {
        use sodiumoxide::crypto::generichash;

        let mut hasher =
            generichash::State::new(Some(size), None).map_err(|_error| Error::Internal {
                description: "blake2b failed".into(),
            })?;
        hasher.update(message).map_err(|_error| Error::Internal {
            description: "blake2b failed".into(),
        })?;
        let hash = hasher.finalize().map_err(|_error| Error::Internal {
            description: "blake2b failed".into(),
        })?;

        Ok(hash.as_ref().to_owned())
    }

    fn sign_ed25519(&self, message: &[u8], secret: &[u8]) -> Result<Vec<u8>> {
        use sodiumoxide::crypto::sign;

        let secret = sign::SecretKey::from_slice(secret).ok_or(Error::InvalidSecretKeyBytes)?;
        let signature = sign::sign_detached(message, &secret);
        return Ok(signature.to_bytes().to_vec());
    }

    fn verify_ed25519(&self, message: &[u8], signature: &[u8], public_key: &[u8]) -> Result<bool> {
        use sodiumoxide::crypto::sign;

        let key = sign::PublicKey::from_slice(public_key).ok_or(Error::InvalidPublicKeyBytes)?;
        let signature = sign::ed25519::Signature::from_bytes(&signature)
            .map_err(|_error| Error::InvalidSignatureBytes)?;
        Ok(sign::verify_detached(&signature, &message, &key))
    }

    fn sign_secp256_k1(&self, message: &[u8], secret: &[u8]) -> Result<Vec<u8>> {
        use k256::ecdsa::signature::Signer;

        let sk = k256::ecdsa::SigningKey::from_bytes(secret)
            .map_err(|_error| Error::InvalidSecretKeyBytes)?;

        let signature: k256::ecdsa::Signature = sk.sign(message);

        Ok(signature.to_vec())
    }

    fn verify_secp256_k1(
        &self,
        message: &[u8],
        signature: &[u8],
        public_key: &[u8],
    ) -> Result<bool> {
        use k256::ecdsa::signature::{Signature, Verifier};

        let vk = k256::ecdsa::VerifyingKey::from_sec1_bytes(public_key)
            .map_err(|_error| Error::InvalidPublicKeyBytes)?;
        let signature: k256::ecdsa::Signature = k256::ecdsa::Signature::from_bytes(signature)
            .map_err(|_error| Error::InvalidSignatureBytes)?;
        Ok(vk.verify(message, &signature).is_ok())
    }

    fn sign_p256(&self, message: &[u8], secret: &[u8]) -> Result<Vec<u8>> {
        use p256::ecdsa::signature::Signer;

        let sk = p256::ecdsa::SigningKey::from_bytes(secret)
            .map_err(|_error| Error::InvalidSecretKeyBytes)?;

        let signature: p256::ecdsa::Signature = sk.sign(message);

        Ok(signature.to_vec())
    }

    fn verify_p256(&self, message: &[u8], signature: &[u8], public_key: &[u8]) -> Result<bool> {
        use p256::ecdsa::signature::{Signature, Verifier};

        let vk = p256::ecdsa::VerifyingKey::from_sec1_bytes(public_key)
            .map_err(|_error| Error::InvalidPublicKeyBytes)?;
        let signature: p256::ecdsa::Signature = p256::ecdsa::Signature::from_bytes(signature)
            .map_err(|_error| Error::InvalidSignatureBytes)?;
        Ok(vk.verify(message, &signature).is_ok())
    }
}

#[cfg(test)]
mod test {
    use super::*;

    fn ed25519_pair() -> (&'static [u8], &'static [u8]) {
        (
            &[
                138, 86, 201, 43, 125, 244, 132, 30, 161, 167, 155, 45, 170, 71, 139, 154, 98, 159,
                243, 89, 224, 15, 211, 68, 224, 197, 251, 209, 57, 233, 17, 79, 32, 140, 29, 13,
                236, 146, 180, 23, 186, 247, 43, 237, 57, 53, 127, 167, 6, 44, 89, 51, 106, 89,
                129, 250, 35, 156, 31, 66, 104, 65, 234, 131,
            ],
            &[
                32, 140, 29, 13, 236, 146, 180, 23, 186, 247, 43, 237, 57, 53, 127, 167, 6, 44, 89,
                51, 106, 89, 129, 250, 35, 156, 31, 66, 104, 65, 234, 131,
            ],
        )
    }

    fn secp256_k1_pair() -> (&'static [u8], &'static [u8]) {
        (
            &[
                2, 251, 104, 203, 198, 119, 255, 180, 51, 104, 166, 16, 242, 213, 120, 42, 21, 154,
                226, 120, 58, 173, 52, 168, 243, 83, 185, 77, 99, 115, 140, 88,
            ],
            &[
                2, 67, 78, 53, 41, 205, 106, 25, 46, 134, 93, 40, 214, 12, 245, 22, 173, 181, 139,
                176, 116, 185, 193, 125, 253, 60, 69, 217, 198, 151, 184, 51, 51,
            ],
        )
    }

    fn p256_pair() -> (&'static [u8], &'static [u8]) {
        (
            &[
                67, 114, 247, 135, 119, 63, 176, 102, 156, 75, 164, 83, 118, 133, 115, 198, 30, 32,
                173, 9, 97, 96, 67, 223, 60, 241, 106, 183, 230, 191, 185, 75,
            ],
            &[
                3, 151, 224, 199, 108, 168, 80, 52, 156, 251, 118, 132, 18, 28, 95, 199, 81, 111,
                127, 243, 48, 11, 240, 71, 99, 28, 200, 230, 177, 85, 181, 103, 88,
            ],
        )
    }

    #[test]
    fn test_sha256() {
        let cp = DefaultCryptoProvider::new();
        let values: Vec<(&'static [u8], &'static [u8])> = vec![
            (
                &[5],
                &[
                    231, 123, 154, 154, 233, 227, 11, 13, 189, 182, 245, 16, 162, 100, 239, 157,
                    231, 129, 80, 29, 123, 107, 146, 174, 137, 235, 5, 156, 90, 183, 67, 219,
                ],
            ),
            (
                &[232],
                &[
                    230, 242, 7, 80, 154, 250, 57, 8, 218, 17, 108, 230, 26, 117, 118, 149, 66, 72,
                    217, 254, 100, 163, 198, 82, 180, 147, 204, 165, 124, 227, 110, 46,
                ],
            ),
            (
                &[198, 25, 66, 244, 46, 210, 223],
                &[
                    41, 166, 48, 22, 99, 163, 175, 185, 52, 234, 164, 249, 228, 202, 167, 242, 32,
                    250, 193, 2, 185, 235, 107, 46, 88, 169, 69, 239, 198, 180, 196, 65,
                ],
            ),
            (
                &[91, 153, 45, 247, 188, 95, 208, 89, 41, 99],
                &[
                    219, 171, 243, 8, 243, 63, 141, 192, 106, 228, 172, 212, 151, 203, 34, 20, 52,
                    47, 161, 16, 245, 147, 214, 115, 141, 236, 204, 218, 76, 251, 84, 171,
                ],
            ),
            (
                &[
                    216, 196, 197, 10, 51, 195, 253, 102, 136, 225, 146, 141, 249,
                ],
                &[
                    187, 169, 148, 236, 172, 5, 127, 112, 1, 127, 128, 186, 2, 248, 206, 184, 77,
                    3, 24, 237, 172, 96, 103, 98, 82, 136, 186, 255, 65, 252, 195, 169,
                ],
            ),
            (
                &[
                    162, 10, 204, 150, 253, 130, 126, 138, 110, 118, 253, 118, 8, 85, 45, 106,
                ],
                &[
                    191, 173, 24, 245, 192, 34, 41, 184, 222, 37, 149, 230, 97, 227, 95, 87, 168,
                    196, 229, 149, 168, 11, 8, 116, 45, 128, 31, 174, 87, 192, 1, 194,
                ],
            ),
            (
                &[
                    8, 237, 44, 83, 82, 114, 130, 14, 183, 132, 83, 88, 111, 108, 92, 217, 40, 118,
                    176,
                ],
                &[
                    62, 19, 183, 101, 134, 160, 147, 63, 57, 1, 12, 202, 109, 85, 236, 97, 188,
                    153, 231, 57, 113, 200, 87, 136, 208, 95, 137, 224, 234, 204, 248, 44,
                ],
            ),
        ];
        for (message, expected) in values {
            let hashed = cp.sha256(message);
            assert_eq!(expected, hashed);
        }
    }

    #[test]
    fn test_blake2b() -> Result<()> {
        let cp = DefaultCryptoProvider::new();
        let values: Vec<((&'static [u8], usize), &'static [u8])> = vec![
            (
                (&[5], 16),
                &[
                    174, 212, 251, 183, 209, 87, 13, 208, 187, 184, 163, 220, 41, 60, 2, 109,
                ],
            ),
            (
                (&[232], 17),
                &[
                    26, 194, 124, 128, 79, 131, 145, 185, 117, 92, 18, 253, 244, 172, 151, 111, 91,
                ],
            ),
            (
                (&[198, 25, 66, 244, 46, 210, 223], 20),
                &[
                    100, 120, 77, 133, 18, 167, 103, 33, 106, 110, 28, 73, 218, 108, 26, 128, 47,
                    34, 48, 250,
                ],
            ),
            (
                (&[91, 153, 45, 247, 188, 95, 208, 89, 41, 99], 18),
                &[
                    247, 43, 151, 85, 189, 16, 34, 178, 112, 242, 39, 56, 122, 153, 213, 134, 184,
                    235,
                ],
            ),
            (
                (
                    &[
                        216, 196, 197, 10, 51, 195, 253, 102, 136, 225, 146, 141, 249,
                    ],
                    19,
                ),
                &[
                    167, 243, 83, 66, 151, 34, 117, 146, 193, 175, 26, 177, 38, 127, 158, 75, 217,
                    157, 249,
                ],
            ),
            (
                (
                    &[
                        162, 10, 204, 150, 253, 130, 126, 138, 110, 118, 253, 118, 8, 85, 45, 106,
                    ],
                    32,
                ),
                &[
                    149, 66, 94, 41, 248, 162, 176, 1, 175, 163, 41, 123, 117, 245, 3, 72, 0, 194,
                    231, 60, 47, 7, 212, 122, 118, 95, 11, 98, 31, 140, 204, 64,
                ],
            ),
            (
                (
                    &[
                        8, 237, 44, 83, 82, 114, 130, 14, 183, 132, 83, 88, 111, 108, 92, 217, 40,
                        118, 176,
                    ],
                    64,
                ),
                &[
                    207, 36, 98, 207, 203, 183, 54, 157, 111, 4, 64, 81, 195, 251, 61, 193, 137,
                    44, 228, 29, 76, 103, 46, 116, 2, 56, 128, 85, 108, 250, 135, 193, 182, 229,
                    166, 43, 14, 130, 204, 83, 154, 196, 143, 145, 120, 13, 210, 93, 147, 103, 173,
                    88, 136, 226, 36, 207, 118, 195, 226, 23, 60, 70, 18, 41,
                ],
            ),
        ];

        for ((message, size), expected) in values {
            let hashed = cp.blake2b(message, size)?;
            assert_eq!(expected, hashed)
        }

        Ok(())
    }

    #[test]
    fn test_ed25519_sign() -> Result<()> {
        let cp = DefaultCryptoProvider::new();
        let values: Vec<(&'static [u8], &'static [u8])> = vec![
            (
                &[
                    187, 103, 163, 186, 154, 198, 79, 184, 154, 180, 128, 246, 52, 117, 95, 13,
                    146, 194, 99, 249, 128, 184, 112, 93, 187, 36, 179, 1, 10, 59, 30, 105,
                ],
                &[
                    243, 215, 194, 90, 109, 213, 83, 238, 154, 85, 139, 71, 14, 62, 191, 230, 7,
                    184, 231, 37, 218, 148, 111, 105, 132, 227, 162, 169, 225, 128, 80, 160, 79,
                    180, 93, 252, 39, 85, 135, 99, 169, 51, 158, 132, 26, 242, 23, 20, 201, 208,
                    56, 183, 16, 131, 9, 117, 173, 146, 162, 143, 180, 179, 50, 5,
                ],
            ),
            (
                &[
                    162, 95, 108, 242, 149, 88, 93, 127, 72, 2, 237, 97, 203, 77, 244, 77, 74, 245,
                    220, 17, 196, 174, 134, 246, 26, 44, 171, 143, 220, 219, 255, 192,
                ],
                &[
                    88, 26, 2, 141, 142, 99, 116, 35, 227, 43, 80, 185, 111, 248, 99, 110, 12, 10,
                    104, 211, 38, 82, 196, 147, 164, 255, 55, 33, 245, 13, 1, 123, 54, 234, 217,
                    207, 26, 198, 131, 15, 174, 120, 152, 26, 103, 163, 229, 9, 99, 140, 48, 138,
                    2, 176, 239, 253, 23, 68, 46, 183, 105, 12, 26, 13,
                ],
            ),
        ];
        let secret = ed25519_pair().0;
        for (message, expected) in values {
            let signature = cp.sign_ed25519(message, secret)?;
            assert_eq!(expected, signature);
        }

        Ok(())
    }

    #[test]
    fn test_ed25519_verify() -> Result<()> {
        let cp = DefaultCryptoProvider::new();
        let values: Vec<((&'static [u8], &'static [u8]), bool)> = vec![
            (
                (
                    &[
                        187, 103, 163, 186, 154, 198, 79, 184, 154, 180, 128, 246, 52, 117, 95, 13,
                        146, 194, 99, 249, 128, 184, 112, 93, 187, 36, 179, 1, 10, 59, 30, 105,
                    ],
                    &[
                        243, 215, 194, 90, 109, 213, 83, 238, 154, 85, 139, 71, 14, 62, 191, 230,
                        7, 184, 231, 37, 218, 148, 111, 105, 132, 227, 162, 169, 225, 128, 80, 160,
                        79, 180, 93, 252, 39, 85, 135, 99, 169, 51, 158, 132, 26, 242, 23, 20, 201,
                        208, 56, 183, 16, 131, 9, 117, 173, 146, 162, 143, 180, 179, 50, 5,
                    ],
                ),
                true,
            ),
            (
                (
                    &[
                        162, 95, 108, 242, 149, 88, 93, 127, 72, 2, 237, 97, 203, 77, 244, 77, 74,
                        245, 220, 17, 196, 174, 134, 246, 26, 44, 171, 143, 220, 219, 255, 192,
                    ],
                    &[
                        88, 26, 2, 141, 142, 99, 116, 35, 227, 43, 80, 185, 111, 248, 99, 110, 12,
                        10, 104, 211, 38, 82, 196, 147, 164, 255, 55, 33, 245, 13, 1, 123, 54, 234,
                        217, 207, 26, 198, 131, 15, 174, 120, 152, 26, 103, 163, 229, 9, 99, 140,
                        48, 138, 2, 176, 239, 253, 23, 68, 46, 183, 105, 12, 26, 13,
                    ],
                ),
                true,
            ),
            (
                (
                    &[
                        187, 103, 163, 186, 154, 198, 79, 184, 154, 180, 128, 246, 52, 117, 95, 13,
                        146, 194, 99, 249, 128, 184, 112, 93, 187, 36, 179, 1, 10, 59, 30, 105,
                    ],
                    &[
                        88, 26, 2, 141, 142, 99, 116, 35, 227, 43, 80, 185, 111, 248, 99, 110, 12,
                        10, 104, 211, 38, 82, 196, 147, 164, 255, 55, 33, 245, 13, 1, 123, 54, 234,
                        217, 207, 26, 198, 131, 15, 174, 120, 152, 26, 103, 163, 229, 9, 99, 140,
                        48, 138, 2, 176, 239, 253, 23, 68, 46, 183, 105, 12, 26, 13,
                    ],
                ),
                false,
            ),
            (
                (
                    &[
                        162, 95, 108, 242, 149, 88, 93, 127, 72, 2, 237, 97, 203, 77, 244, 77, 74,
                        245, 220, 17, 196, 174, 134, 246, 26, 44, 171, 143, 220, 219, 255, 192,
                    ],
                    &[
                        243, 215, 194, 90, 109, 213, 83, 238, 154, 85, 139, 71, 14, 62, 191, 230,
                        7, 184, 231, 37, 218, 148, 111, 105, 132, 227, 162, 169, 225, 128, 80, 160,
                        79, 180, 93, 252, 39, 85, 135, 99, 169, 51, 158, 132, 26, 242, 23, 20, 201,
                        208, 56, 183, 16, 131, 9, 117, 173, 146, 162, 143, 180, 179, 50, 5,
                    ],
                ),
                false,
            ),
        ];

        let public_key = ed25519_pair().1;
        for ((message, signature), expected) in values {
            let result = cp.verify_ed25519(message, signature, public_key)?;
            assert_eq!(expected, result);
        }

        Ok(())
    }

    #[test]
    fn test_secp256_k1_sign() -> Result<()> {
        let cp = DefaultCryptoProvider::new();
        let values: Vec<(&'static [u8], &'static [u8])> = vec![
            (
                &[
                    187, 103, 163, 186, 154, 198, 79, 184, 154, 180, 128, 246, 52, 117, 95, 13,
                    146, 194, 99, 249, 128, 184, 112, 93, 187, 36, 179, 1, 10, 59, 30, 105,
                ],
                &[
                    94, 27, 125, 173, 22, 236, 142, 61, 138, 175, 27, 174, 254, 241, 227, 168, 161,
                    106, 210, 168, 244, 148, 135, 226, 173, 29, 153, 123, 31, 151, 204, 160, 12,
                    62, 47, 5, 212, 224, 246, 234, 35, 35, 110, 19, 150, 220, 252, 221, 217, 143,
                    23, 70, 237, 19, 182, 73, 17, 224, 135, 215, 169, 244, 242, 24,
                ],
                // &[
                //     194, 114, 181, 200, 244, 171, 164, 203, 172, 154, 64, 2, 6, 57, 66, 158, 219,
                //     33, 26, 51, 134, 191, 146, 119, 153, 236, 99, 36, 165, 66, 57, 199, 117, 131,
                //     176, 3, 181, 154, 123, 188, 113, 17, 35, 15, 5, 48, 192, 93, 84, 77, 87, 13,
                //     231, 188, 94, 243, 2, 221, 220, 189, 98, 40, 28, 190,
                // ],
            ),
            (
                &[
                    162, 95, 108, 242, 149, 88, 93, 127, 72, 2, 237, 97, 203, 77, 244, 77, 74, 245,
                    220, 17, 196, 174, 134, 246, 26, 44, 171, 143, 220, 219, 255, 192,
                ],
                &[
                    232, 163, 117, 77, 11, 127, 127, 64, 128, 148, 125, 193, 6, 124, 132, 242, 15,
                    173, 6, 243, 49, 102, 229, 119, 163, 121, 133, 252, 11, 40, 206, 109, 13, 55,
                    120, 254, 180, 124, 14, 51, 9, 94, 253, 53, 216, 234, 145, 233, 10, 122, 35,
                    215, 167, 248, 104, 222, 119, 26, 111, 121, 54, 240, 7, 115,
                ],
                // &[
                //     37, 152, 77, 200, 78, 92, 29, 51, 174, 133, 202, 17, 177, 218, 50, 147, 143, 3,
                //     246, 254, 76, 106, 138, 229, 195, 203, 149, 166, 45, 111, 228, 55, 23, 115,
                //     228, 132, 19, 69, 138, 253, 60, 26, 65, 112, 120, 228, 129, 85, 3, 127, 166,
                //     78, 187, 225, 77, 140, 95, 166, 43, 105, 47, 215, 250, 155,
                // ],
            ),
        ];
        let secret = secp256_k1_pair().0;
        for (message, expected) in values {
            let signature = cp.sign_secp256_k1(message, secret)?;
            assert_eq!(expected, signature);
        }

        Ok(())
    }

    #[test]
    fn test_secp256_k1_verify() -> Result<()> {
        let cp = DefaultCryptoProvider::new();
        let values: Vec<((&'static [u8], &'static [u8]), bool)> = vec![
            (
                (
                    &[
                        187, 103, 163, 186, 154, 198, 79, 184, 154, 180, 128, 246, 52, 117, 95, 13,
                        146, 194, 99, 249, 128, 184, 112, 93, 187, 36, 179, 1, 10, 59, 30, 105,
                    ],
                    &[
                        94, 27, 125, 173, 22, 236, 142, 61, 138, 175, 27, 174, 254, 241, 227, 168,
                        161, 106, 210, 168, 244, 148, 135, 226, 173, 29, 153, 123, 31, 151, 204,
                        160, 12, 62, 47, 5, 212, 224, 246, 234, 35, 35, 110, 19, 150, 220, 252,
                        221, 217, 143, 23, 70, 237, 19, 182, 73, 17, 224, 135, 215, 169, 244, 242,
                        24,
                    ],
                ),
                true, // &[
                      //     194, 114, 181, 200, 244, 171, 164, 203, 172, 154, 64, 2, 6, 57, 66, 158, 219,
                      //     33, 26, 51, 134, 191, 146, 119, 153, 236, 99, 36, 165, 66, 57, 199, 117, 131,
                      //     176, 3, 181, 154, 123, 188, 113, 17, 35, 15, 5, 48, 192, 93, 84, 77, 87, 13,
                      //     231, 188, 94, 243, 2, 221, 220, 189, 98, 40, 28, 190,
                      // ],
            ),
            (
                (
                    &[
                        162, 95, 108, 242, 149, 88, 93, 127, 72, 2, 237, 97, 203, 77, 244, 77, 74,
                        245, 220, 17, 196, 174, 134, 246, 26, 44, 171, 143, 220, 219, 255, 192,
                    ],
                    &[
                        232, 163, 117, 77, 11, 127, 127, 64, 128, 148, 125, 193, 6, 124, 132, 242,
                        15, 173, 6, 243, 49, 102, 229, 119, 163, 121, 133, 252, 11, 40, 206, 109,
                        13, 55, 120, 254, 180, 124, 14, 51, 9, 94, 253, 53, 216, 234, 145, 233, 10,
                        122, 35, 215, 167, 248, 104, 222, 119, 26, 111, 121, 54, 240, 7, 115,
                    ],
                ),
                true, // &[
                      //     37, 152, 77, 200, 78, 92, 29, 51, 174, 133, 202, 17, 177, 218, 50, 147, 143, 3,
                      //     246, 254, 76, 106, 138, 229, 195, 203, 149, 166, 45, 111, 228, 55, 23, 115,
                      //     228, 132, 19, 69, 138, 253, 60, 26, 65, 112, 120, 228, 129, 85, 3, 127, 166,
                      //     78, 187, 225, 77, 140, 95, 166, 43, 105, 47, 215, 250, 155,
                      // ],
            ),
            (
                (
                    &[
                        187, 103, 163, 186, 154, 198, 79, 184, 154, 180, 128, 246, 52, 117, 95, 13,
                        146, 194, 99, 249, 128, 184, 112, 93, 187, 36, 179, 1, 10, 59, 30, 105,
                    ],
                    &[
                        232, 163, 117, 77, 11, 127, 127, 64, 128, 148, 125, 193, 6, 124, 132, 242,
                        15, 173, 6, 243, 49, 102, 229, 119, 163, 121, 133, 252, 11, 40, 206, 109,
                        13, 55, 120, 254, 180, 124, 14, 51, 9, 94, 253, 53, 216, 234, 145, 233, 10,
                        122, 35, 215, 167, 248, 104, 222, 119, 26, 111, 121, 54, 240, 7, 115,
                    ],
                ),
                false, // &[
                       //     194, 114, 181, 200, 244, 171, 164, 203, 172, 154, 64, 2, 6, 57, 66, 158, 219,
                       //     33, 26, 51, 134, 191, 146, 119, 153, 236, 99, 36, 165, 66, 57, 199, 117, 131,
                       //     176, 3, 181, 154, 123, 188, 113, 17, 35, 15, 5, 48, 192, 93, 84, 77, 87, 13,
                       //     231, 188, 94, 243, 2, 221, 220, 189, 98, 40, 28, 190,
                       // ],
            ),
            (
                (
                    &[
                        162, 95, 108, 242, 149, 88, 93, 127, 72, 2, 237, 97, 203, 77, 244, 77, 74,
                        245, 220, 17, 196, 174, 134, 246, 26, 44, 171, 143, 220, 219, 255, 192,
                    ],
                    &[
                        94, 27, 125, 173, 22, 236, 142, 61, 138, 175, 27, 174, 254, 241, 227, 168,
                        161, 106, 210, 168, 244, 148, 135, 226, 173, 29, 153, 123, 31, 151, 204,
                        160, 12, 62, 47, 5, 212, 224, 246, 234, 35, 35, 110, 19, 150, 220, 252,
                        221, 217, 143, 23, 70, 237, 19, 182, 73, 17, 224, 135, 215, 169, 244, 242,
                        24,
                    ],
                ),
                false, // &[
                       //     37, 152, 77, 200, 78, 92, 29, 51, 174, 133, 202, 17, 177, 218, 50, 147, 143, 3,
                       //     246, 254, 76, 106, 138, 229, 195, 203, 149, 166, 45, 111, 228, 55, 23, 115,
                       //     228, 132, 19, 69, 138, 253, 60, 26, 65, 112, 120, 228, 129, 85, 3, 127, 166,
                       //     78, 187, 225, 77, 140, 95, 166, 43, 105, 47, 215, 250, 155,
                       // ],
            ),
        ];

        let public_key = secp256_k1_pair().1;
        for ((message, signature), expected) in values {
            let result = cp.verify_secp256_k1(message, signature, public_key)?;
            assert_eq!(expected, result);
        }

        Ok(())
    }

    #[test]
    fn test_p256_sign() -> Result<()> {
        let cp = DefaultCryptoProvider::new();
        let values: Vec<(&'static [u8], &'static [u8])> = vec![
            (
                &[
                    187, 103, 163, 186, 154, 198, 79, 184, 154, 180, 128, 246, 52, 117, 95, 13,
                    146, 194, 99, 249, 128, 184, 112, 93, 187, 36, 179, 1, 10, 59, 30, 105,
                ],
                &[
                    14, 120, 187, 142, 58, 192, 142, 25, 40, 243, 70, 168, 114, 187, 186, 52, 112,
                    121, 78, 104, 250, 208, 150, 126, 71, 244, 71, 211, 107, 50, 159, 54, 134, 189,
                    215, 102, 104, 49, 34, 168, 236, 239, 146, 63, 69, 133, 85, 165, 25, 45, 144,
                    87, 135, 234, 140, 179, 85, 59, 56, 255, 250, 31, 16, 167,
                ],
                // &[
                //     224, 253, 177, 134, 177, 64, 222, 121, 95, 115, 195, 14, 216, 194, 105, 162,
                //     167, 27, 164, 192, 98, 80, 44, 139, 239, 232, 93, 56, 4, 79, 217, 236, 74, 50,
                //     70, 182, 186, 127, 176, 96, 69, 162, 209, 33, 228, 246, 200, 226, 170, 144,
                //     190, 1, 181, 169, 101, 2, 232, 229, 52, 7, 187, 177, 59, 194,
                // ],
            ),
            (
                &[
                    162, 95, 108, 242, 149, 88, 93, 127, 72, 2, 237, 97, 203, 77, 244, 77, 74, 245,
                    220, 17, 196, 174, 134, 246, 26, 44, 171, 143, 220, 219, 255, 192,
                ],
                &[
                    90, 224, 245, 7, 45, 98, 111, 28, 156, 0, 63, 163, 36, 153, 102, 155, 104, 79,
                    166, 31, 18, 171, 153, 97, 104, 191, 23, 61, 109, 106, 6, 94, 177, 138, 152,
                    76, 72, 114, 54, 166, 200, 206, 91, 59, 138, 70, 233, 100, 183, 35, 122, 190,
                    35, 199, 249, 109, 233, 94, 65, 48, 245, 54, 243, 122,
                ],
                // &[
                //     60, 28, 124, 81, 248, 206, 221, 195, 30, 108, 129, 164, 107, 49, 71, 181, 44,
                //     250, 52, 191, 150, 57, 175, 11, 84, 31, 126, 185, 78, 169, 53, 110, 114, 158,
                //     242, 213, 124, 141, 190, 104, 106, 135, 181, 86, 149, 100, 61, 143, 164, 175,
                //     80, 225, 127, 179, 40, 8, 224, 233, 201, 74, 49, 90, 118, 58,
                // ],
            ),
        ];
        let secret = p256_pair().0;
        for (message, expected) in values {
            let signature = cp.sign_p256(message, secret)?;
            assert_eq!(expected, signature);
        }

        Ok(())
    }

    #[test]
    fn test_p256_verify() -> Result<()> {
        let cp = DefaultCryptoProvider::new();
        let values: Vec<((&'static [u8], &'static [u8]), bool)> = vec![
            (
                (
                    &[
                        187, 103, 163, 186, 154, 198, 79, 184, 154, 180, 128, 246, 52, 117, 95, 13,
                        146, 194, 99, 249, 128, 184, 112, 93, 187, 36, 179, 1, 10, 59, 30, 105,
                    ],
                    &[
                        14, 120, 187, 142, 58, 192, 142, 25, 40, 243, 70, 168, 114, 187, 186, 52,
                        112, 121, 78, 104, 250, 208, 150, 126, 71, 244, 71, 211, 107, 50, 159, 54,
                        134, 189, 215, 102, 104, 49, 34, 168, 236, 239, 146, 63, 69, 133, 85, 165,
                        25, 45, 144, 87, 135, 234, 140, 179, 85, 59, 56, 255, 250, 31, 16, 167,
                    ],
                ),
                true, // &[
                      //     224, 253, 177, 134, 177, 64, 222, 121, 95, 115, 195, 14, 216, 194, 105, 162,
                      //     167, 27, 164, 192, 98, 80, 44, 139, 239, 232, 93, 56, 4, 79, 217, 236, 74, 50,
                      //     70, 182, 186, 127, 176, 96, 69, 162, 209, 33, 228, 246, 200, 226, 170, 144,
                      //     190, 1, 181, 169, 101, 2, 232, 229, 52, 7, 187, 177, 59, 194,
                      // ],
            ),
            (
                (
                    &[
                        162, 95, 108, 242, 149, 88, 93, 127, 72, 2, 237, 97, 203, 77, 244, 77, 74,
                        245, 220, 17, 196, 174, 134, 246, 26, 44, 171, 143, 220, 219, 255, 192,
                    ],
                    &[
                        90, 224, 245, 7, 45, 98, 111, 28, 156, 0, 63, 163, 36, 153, 102, 155, 104,
                        79, 166, 31, 18, 171, 153, 97, 104, 191, 23, 61, 109, 106, 6, 94, 177, 138,
                        152, 76, 72, 114, 54, 166, 200, 206, 91, 59, 138, 70, 233, 100, 183, 35,
                        122, 190, 35, 199, 249, 109, 233, 94, 65, 48, 245, 54, 243, 122,
                    ],
                ),
                true, // &[
                      //     60, 28, 124, 81, 248, 206, 221, 195, 30, 108, 129, 164, 107, 49, 71, 181, 44,
                      //     250, 52, 191, 150, 57, 175, 11, 84, 31, 126, 185, 78, 169, 53, 110, 114, 158,
                      //     242, 213, 124, 141, 190, 104, 106, 135, 181, 86, 149, 100, 61, 143, 164, 175,
                      //     80, 225, 127, 179, 40, 8, 224, 233, 201, 74, 49, 90, 118, 58,
                      // ],
            ),
            (
                (
                    &[
                        187, 103, 163, 186, 154, 198, 79, 184, 154, 180, 128, 246, 52, 117, 95, 13,
                        146, 194, 99, 249, 128, 184, 112, 93, 187, 36, 179, 1, 10, 59, 30, 105,
                    ],
                    &[
                        232, 163, 117, 77, 11, 127, 127, 64, 128, 148, 125, 193, 6, 124, 132, 242,
                        15, 173, 6, 243, 49, 102, 229, 119, 163, 121, 133, 252, 11, 40, 206, 109,
                        13, 55, 120, 254, 180, 124, 14, 51, 9, 94, 253, 53, 216, 234, 145, 233, 10,
                        122, 35, 215, 167, 248, 104, 222, 119, 26, 111, 121, 54, 240, 7, 115,
                    ],
                ),
                false, // &[
                       //     224, 253, 177, 134, 177, 64, 222, 121, 95, 115, 195, 14, 216, 194, 105, 162,
                       //     167, 27, 164, 192, 98, 80, 44, 139, 239, 232, 93, 56, 4, 79, 217, 236, 74, 50,
                       //     70, 182, 186, 127, 176, 96, 69, 162, 209, 33, 228, 246, 200, 226, 170, 144,
                       //     190, 1, 181, 169, 101, 2, 232, 229, 52, 7, 187, 177, 59, 194,
                       // ],
            ),
            (
                (
                    &[
                        162, 95, 108, 242, 149, 88, 93, 127, 72, 2, 237, 97, 203, 77, 244, 77, 74,
                        245, 220, 17, 196, 174, 134, 246, 26, 44, 171, 143, 220, 219, 255, 192,
                    ],
                    &[
                        94, 27, 125, 173, 22, 236, 142, 61, 138, 175, 27, 174, 254, 241, 227, 168,
                        161, 106, 210, 168, 244, 148, 135, 226, 173, 29, 153, 123, 31, 151, 204,
                        160, 12, 62, 47, 5, 212, 224, 246, 234, 35, 35, 110, 19, 150, 220, 252,
                        221, 217, 143, 23, 70, 237, 19, 182, 73, 17, 224, 135, 215, 169, 244, 242,
                        24,
                    ],
                ),
                false, // &[
                       //     60, 28, 124, 81, 248, 206, 221, 195, 30, 108, 129, 164, 107, 49, 71, 181, 44,
                       //     250, 52, 191, 150, 57, 175, 11, 84, 31, 126, 185, 78, 169, 53, 110, 114, 158,
                       //     242, 213, 124, 141, 190, 104, 106, 135, 181, 86, 149, 100, 61, 143, 164, 175,
                       //     80, 225, 127, 179, 40, 8, 224, 233, 201, 74, 49, 90, 118, 58,
                       // ],
            ),
        ];

        let public_key = p256_pair().1;
        for ((message, signature), expected) in values {
            let result = cp.verify_p256(message, signature, public_key)?;
            assert_eq!(expected, result);
        }

        Ok(())
    }
}
